name: Kaggle Notebook Executor

on:
  workflow_dispatch:
  repository_dispatch:
    types: [cron-trigger]

jobs:
  execute-notebooks:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install dependencies
      run: |
        pip install kaggle
    
    - name: Execute notebooks in parallel
      run: |
        python << 'EOF'
        import os
        import subprocess
        import json
        import sys
        from datetime import datetime
        from pathlib import Path
        import shutil
        from concurrent.futures import ThreadPoolExecutor, as_completed
        import threading
        import time

        SOURCE_ACCOUNT = {
            "username": "shreevathsbbhh",
            "key": "9f167cdee8a045c97ca6a2f82c6701f9"
        }

        DEST_ACCOUNTS = {
            "distinct4exist": {
                "username": "distinct4exist",
                "key": "c2767798395ca8c007e931d6f9d42752"
            },
            "shreevathsaz": {
                "username": "shreevathsaz",
                "key": "2faa3199cb4f8a0d88a8999604ac6770"
            }
        }

        # UPDATED NOTEBOOKS LIST
        NOTEBOOKS = [
            {
                "source_slug": "shreevathsbbhh/new-20-1", 
                "notebook_name": "new-20-1", 
                "dest_slug": "distinct4exist/new-20-1",
                "dest_account": "distinct4exist"
            },
            {
                "source_slug": "shreevathsbbhh/bulk-2-7-1", 
                "notebook_name": "bulk-2-7-1", 
                "dest_slug": "distinct4exist/bulk-2-7-1",
                "dest_account": "distinct4exist"
            },
            {
                "source_slug": "shreevathsbbhh/bulk-2-7-2",   
                "notebook_name": "bulk-2-7-2",   
                "dest_slug": "shreevathsaz/bulk-2-7-2",
                "dest_account": "shreevathsaz"
            }
        ]

        log_lock = threading.Lock()

        def log(msg, symbol="â„¹ï¸"):
            timestamp = datetime.utcnow().strftime('%H:%M:%S')
            with log_lock:
                print(f"[{timestamp}] {symbol} {msg}")
                sys.stdout.flush()

        def setup_kaggle_auth(account):
            kaggle_dir = Path.home() / ".kaggle"
            kaggle_dir.mkdir(exist_ok=True)
            kaggle_json = kaggle_dir / "kaggle.json"
            
            with open(kaggle_json, 'w') as f:
                json.dump({"username": account["username"], "key": account["key"]}, f)
            
            kaggle_json.chmod(0o600)
            log(f"Auth set: {account['username']}", "ðŸ”‘")

        def run_cmd(cmd, timeout=180):
            try:
                result = subprocess.run(
                    cmd, shell=True, capture_output=True, 
                    text=True, timeout=timeout
                )
                return result.returncode == 0, result.stdout, result.stderr
            except subprocess.TimeoutExpired:
                return False, "", "Command timeout after 180s"
            except Exception as e:
                return False, "", str(e)

        def execute_notebook(nb):
            log(f"START: {nb['notebook_name']} â†’ {nb['dest_account']}", "ðŸš€")
            
            temp_dir = Path(f"./temp_{nb['notebook_name']}")
            original_dir = os.getcwd()
            
            try:
                # Clean temp directory
                if temp_dir.exists():
                    shutil.rmtree(temp_dir)
                temp_dir.mkdir()
                
                # STEP 1: Pull from source
                setup_kaggle_auth(SOURCE_ACCOUNT)
                time.sleep(0.5)  # Give filesystem time to update
                
                log(f"Pulling {nb['notebook_name']}...", "ðŸ“¥")
                success, stdout, stderr = run_cmd(
                    f"kaggle kernels pull {nb['source_slug']} -p {temp_dir} -m"
                )
                
                if not success:
                    log(f"PULL FAILED: {nb['notebook_name']}", "âŒ")
                    log(f"Error: {stderr[:300]}", "")
                    log(f"Output: {stdout[:300]}", "")
                    return False
                
                log(f"Pull OK: {nb['notebook_name']}", "âœ…")
                
                # STEP 2: Verify files exist
                files = list(temp_dir.glob("*"))
                log(f"Files pulled: {[f.name for f in files]}", "ðŸ“„")
                
                metadata_file = temp_dir / "kernel-metadata.json"
                
                if not metadata_file.exists():
                    log(f"MISSING metadata: {nb['notebook_name']}", "âŒ")
                    return False
                
                # STEP 3: Update metadata
                with open(metadata_file, 'r') as f:
                    metadata = json.load(f)
                
                log(f"Original metadata: {metadata.get('id', 'N/A')}", "ðŸ“")
                
                timestamp = datetime.utcnow().strftime('%Y%m%d-%H%M%S')
                
                metadata.update({
                    'id': nb['dest_slug'],
                    'slug': nb['notebook_name'],
                    'title': f"{nb['notebook_name']}-{timestamp}"
                })
                
                with open(metadata_file, 'w') as f:
                    json.dump(metadata, f, indent=2)
                
                log(f"Updated to: {metadata['id']}", "ðŸ“")
                
                # STEP 4: Switch to destination account
                target_account_key = nb.get('dest_account')
                if target_account_key not in DEST_ACCOUNTS:
                    log(f"Unknown account: {target_account_key}", "âŒ")
                    return False
                
                setup_kaggle_auth(DEST_ACCOUNTS[target_account_key])
                time.sleep(0.5)  # Give filesystem time to update
                
                # STEP 5: Push to destination
                os.chdir(temp_dir)
                
                log(f"Pushing {nb['notebook_name']}...", "ðŸ“¤")
                success, stdout, stderr = run_cmd("kaggle kernels push", timeout=240)
                
                os.chdir(original_dir)
                
                if not success:
                    log(f"PUSH FAILED: {nb['notebook_name']}", "âŒ")
                    log(f"Error: {stderr[:300]}", "")
                    log(f"Output: {stdout[:300]}", "")
                    return False
                
                log(f"Push OK: {nb['notebook_name']}", "âœ…")
                log(f"URL: https://www.kaggle.com/code/{nb['dest_slug']}", "ðŸ”—")
                
                return True
                
            except Exception as e:
                log(f"EXCEPTION: {nb['notebook_name']}", "âŒ")
                log(f"Error: {str(e)[:300]}", "")
                import traceback
                log(f"Trace: {traceback.format_exc()[:500]}", "")
                return False
                
            finally:
                if os.getcwd() != original_dir:
                    os.chdir(original_dir)
                if temp_dir.exists():
                    try:
                        shutil.rmtree(temp_dir)
                    except Exception as cleanup_error:
                        log(f"Cleanup warning: {str(cleanup_error)[:100]}", "âš ï¸")

        def execute_all():
            start = datetime.utcnow()
            log(f"EXECUTION STARTED: {start.isoformat()}", "ðŸš€")
            log(f"Total notebooks: {len(NOTEBOOKS)}", "ðŸ“Š")
            
            results = {}
            
            # Execute sequentially to avoid auth conflicts
            for nb in NOTEBOOKS:
                log("â•" * 70, "")
                success = execute_notebook(nb)
                results[nb['notebook_name']] = success
                time.sleep(2)  # Wait between notebooks
            
            success_count = sum(results.values())
            duration = (datetime.utcnow() - start).total_seconds()
            
            log("â•" * 70, "")
            log(f"COMPLETED: {success_count}/{len(results)} successful | {duration:.1f}s", "")
            log("â•" * 70, "")
            
            for nb_name, success in results.items():
                status = "âœ…" if success else "âŒ"
                log(f"{status} {nb_name}", "")
            
            # Exit with error if any failed
            if success_count < len(results):
                log(f"FAILURES DETECTED: {len(results) - success_count} notebooks failed", "âŒ")
                sys.exit(1)

        execute_all()
        EOF
